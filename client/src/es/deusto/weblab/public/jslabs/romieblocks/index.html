<!DOCTYPE html>
<html lang="es">
<head>
	<title>Romie Blockly</title>
	<meta charset="UTF-8">

	<link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.min.css">

	<script src="bower_components/jquery/dist/jquery.min.js"></script>
	<script src="../../jslib/weblabjs.js"></script>
	<script src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
	<script src="bower_components/js-interpreter/acorn_interpreter.js"></script>
	<script src="bower_components/google-blockly/blockly_compressed.js"></script>
	<script src="bower_components/google-blockly/blocks_compressed.js"></script>
	<script src="bower_components/google-blockly/javascript_compressed.js"></script>
	<script src="bower_components/google-blockly/msg/js/es.js"></script>
	<script src="js/functions.js"></script>
	<script src="js/blocks.js"></script>
</head>
<body>
	<p style="text-align: center;">Aquí tienes un editor de código visual. Ahora puedes programar el robot y decidir qué hará en el laberinto. Cuando hayas acabado, reserva el robot para poder ver </p>

	<div id="blocklyDiv" style="margin: auto; height: 500px; width: 90%;"></div>

	<xml id="toolbox" style="display: none">
		<block type="controls_if"></block>
		<block type="logic_compare"></block>
		<block type="controls_repeat_ext"></block>
		<block type="math_number"></block>
		<block type="romie_move_forward"></block>
		<block type="romie_turn_left"></block>
		<block type="romie_turn_right"></block>
		<!-- <block type="check_wall"></block> -->
	</xml>

	<script>
		var workspace = Blockly.inject('blocklyDiv',
			{media: 'bower_components/google-blockly/media/',
			toolbox: document.getElementById('toolbox')});

		function test(response) {
			function initApi(interpreter, scope) {
				// Add Romie to the context
				var wrapper = function() {
					return interpreter.createPrimitive(romie.isMoving());
				};
				this.setProperty(scope, 'isMoving',
					this.createNativeFunction(wrapper));

				// Add an API function for the forward() block.
				wrapper = function() {
					romie.forward();
				};
				interpreter.setProperty(scope, 'forward',
					interpreter.createNativeFunction(wrapper));

				// Add an API function for the left() block.
				wrapper = function() {
					romie.left();
				};
				interpreter.setProperty(scope, 'left',
					interpreter.createNativeFunction(wrapper));

				// Add an API function for the right() block.
				wrapper = function() {
					romie.right();
				};
				interpreter.setProperty(scope, 'right',
					interpreter.createNativeFunction(wrapper));

				// Add an API function for highlighting blocks.
				wrapper = function(id) {
					id = id ? id.toString() : '';
					return interpreter.createPrimitive(workspace.highlightBlock(id));
				};
				interpreter.setProperty(scope, 'highlightBlock',
					interpreter.createNativeFunction(wrapper));
			}

			Blockly.JavaScript.STATEMENT_PREFIX = 'highlightBlock(%1);\n';
			Blockly.JavaScript.addReservedWords('highlightBlock');
			var myInterpreter = new Interpreter(Blockly.JavaScript.workspaceToCode(workspace), initApi);

			function nextStep() {
				if (myInterpreter.step()) {
					window.setTimeout(nextStep, 40);
				}
			}

			workspace.traceOn(true);
			workspace.highlightBlock(null);
			nextStep();
		}

		Weblab.setOnGetInitialDataCallback(function() {
			console.log("callback chachi");
			return {"blocks": Blockly.Xml.domToText(Blockly.Xml.workspaceToDom(workspace))};
		});

		Weblab.setOnStartInteractionCallback(test);
	</script>
</body>
</html>
